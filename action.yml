name: "Cleanup Transient Deployments"
description: "Cleans up transient deployment artifacts including tags, Docker images, Helm charts, and GitHub deployments"
author: "JD Boivin"

inputs:
  pattern:
    description: 'Pattern suffix to clean (e.g., "rc", "pr-123")'
    required: true
  versions:
    description: 'Space-separated list of versions to clean (e.g., "1.0.0-rc.1 1.0.0-rc.2"). If not specified, versions are detected from git tags matching the pattern.'
    required: false
    default: ""
  token:
    description: "GitHub token with permissions to delete packages and environments"
    required: true
    default: ${{ github.token }}
  registry:
    description: "Container registry URL"
    required: false
    default: "ghcr.io"
  username:
    description: "Username or organization (defaults to repository owner)"
    required: false
    default: ${{ github.repository_owner }}
  repo-owner:
    description: "Repository owner (defaults to current repo owner)"
    required: false
    default: ${{ github.repository_owner }}
  repo-name:
    description: "Repository name (defaults to current repo name)"
    required: false
    default: ${{ github.event.repository.name }}
  docker-image-name:
    description: "Custom Docker image name (defaults to repo name in lowercase)"
    required: false
    default: ""
  helm-chart-name:
    description: "Custom Helm chart name (defaults to charts/{repo-name} in lowercase)"
    required: false
    default: ""
  environment-name:
    description: "Custom environment name (defaults to 'staging' for rc, pattern for pr-XXX)"
    required: false
    default: ""
  kube-config:
    description: "Kubernetes config file content for kubectl access (if not set, Kubernetes cleanup is skipped)"
    required: false
    default: ""
  namespace:
    description: "Kubernetes namespace for Helm release (used when kube-config is provided)"
    required: false
    default: "preview"
  helm:
    description: "Helm release name to uninstall (used when kube-config is provided)"
    required: false
    default: ""

outputs:
  versions:
    description: "Space-separated list of versions that were cleaned up"
    value: ${{ steps.versions.outputs.versions }}
  versions-markdown:
    description: "Markdown-formatted bullet list of versions for GitHub comments"
    value: ${{ steps.versions.outputs.versions_markdown }}

runs:
  using: "composite"
  steps:
    - name: Get versions to clean
      id: versions
      shell: bash
      run: |
        # Use manually provided versions if specified, otherwise detect from git tags
        if [ -n "${{ inputs.versions }}" ]; then
          VERSIONS="${{ inputs.versions }}"
          echo "Using manually provided versions: $VERSIONS"
        else
          git fetch --tags
          VERSIONS=$(git tag -l "v*-${{ inputs.pattern }}.*" | sed 's/^v//' | tr '\n' ' ')
          echo "Detected versions from git tags: $VERSIONS"
        fi

        echo "versions=$VERSIONS" >> $GITHUB_OUTPUT
        echo "Versions to clean: $VERSIONS"

        # Generate markdown-formatted list
        if [ -z "$VERSIONS" ]; then
          echo "versions_markdown=_No versions found to clean_" >> $GITHUB_OUTPUT
        else
          MARKDOWN=$(echo "$VERSIONS" | tr ' ' '\n' | grep -v '^$' | sed 's/^/- /' | tr '\n' '\n')
          # Use multiline output format
          {
            echo "versions_markdown<<EOF"
            echo "$MARKDOWN"
            echo "EOF"
          } >> $GITHUB_OUTPUT
        fi

    - name: Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ inputs.registry }}
        username: ${{ inputs.username }}
        password: ${{ inputs.token || github.token }}

    - name: Set up Helm
      if: inputs.kube-config != ''
      uses: azure/setup-helm@v4

    - name: Setup kubectl
      if: inputs.kube-config != ''
      uses: azure/setup-kubectl@v4

    - name: Configure kubectl
      if: inputs.kube-config != ''
      shell: bash
      run: |
        mkdir -p ~/.kube
        echo "${{ inputs.kube-config }}" > ~/.kube/config
        chmod 600 ~/.kube/config
        echo "✅ Configured kubectl"

    - name: Cleanup Kubernetes/Helm resources
      if: inputs.kube-config != ''
      shell: bash
      run: |
        NAMESPACE="${{ inputs.namespace }}"
        RELEASE_NAME="${{ inputs.helm }}"

        # Verify kubectl connection
        echo "Verifying kubectl connection..."
        kubectl get pods -n "$NAMESPACE" || echo "No pods found or namespace doesn't exist"

        # Uninstall Helm release if name is provided
        if [ -n "$RELEASE_NAME" ]; then
          echo "Uninstalling Helm release: $RELEASE_NAME in namespace: $NAMESPACE"
          helm uninstall "$RELEASE_NAME" --namespace "$NAMESPACE" || echo "Helm release not found or already deleted"
        else
          echo "No Helm release name provided, skipping Helm cleanup"
        fi

    - name: Delete Git Tags
      shell: bash
      run: |
        git fetch --tags

        # Find all tags matching the pattern
        TAGS=$(git tag -l "v*-${{ inputs.pattern }}.*")

        if [ -z "$TAGS" ]; then
          echo "No tags found matching pattern: v*-${{ inputs.pattern }}.*"
          exit 0
        fi

        echo "Found tags to delete:"
        echo "$TAGS"

        # Delete tags locally and remotely
        for tag in $TAGS; do
          echo "Deleting tag: $tag"
          git tag -d "$tag" || true
          git push origin ":refs/tags/$tag" || true
        done

    - name: Delete Docker Images from GHCR
      if: steps.versions.outputs.versions != ''
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
      run: |
        # Enhanced deletion with comprehensive debugging

        VERSIONS="${{ steps.versions.outputs.versions }}"
        OWNER="${{ inputs.repo-owner }}"
        CUSTOM_IMAGE_NAME="${{ inputs.docker-image-name }}"
        REGISTRY="${{ inputs.registry }}"

        # Convert to lowercase
        OWNER=$(echo "$OWNER" | tr '[:upper:]' '[:lower:]')

        # Use custom name if provided, otherwise use repo name
        if [ -n "$CUSTOM_IMAGE_NAME" ]; then
          PACKAGE_NAME="$CUSTOM_IMAGE_NAME"
        else
          PACKAGE_NAME="${{ inputs.repo-name }}"
          PACKAGE_NAME=$(echo "$PACKAGE_NAME" | tr '[:upper:]' '[:lower:]')
        fi

        if [ -z "$VERSIONS" ]; then
          echo "No versions to clean"
          exit 0
        fi

        echo "========================================="
        echo "Docker Image Deletion Configuration:"
        echo "========================================="
        echo "Registry: $REGISTRY"
        echo "Owner: $OWNER"
        echo "Package name: $PACKAGE_NAME"
        echo "Versions to delete: $VERSIONS"
        echo "========================================="

        # First, let's check if we're using organization or user packages
        # Try organization first
        echo "Checking if this is an organization package..."
        ORG_PACKAGES=$(gh api \
          "/orgs/$OWNER/packages?package_type=container" \
          --jq '.[].name' 2>/dev/null || echo "")

        if echo "$ORG_PACKAGES" | grep -q "^$PACKAGE_NAME$"; then
          PACKAGE_TYPE="org"
          API_PREFIX="/orgs/$OWNER"
          echo "✓ Found as organization package"
        else
          PACKAGE_TYPE="user"
          API_PREFIX="/user"
          echo "✓ Assuming user package (or using GITHUB_TOKEN)"
        fi

        echo "Package type: $PACKAGE_TYPE"
        echo "API prefix: $API_PREFIX"

        # List all available versions first for debugging
        echo ""
        echo "Fetching all available versions from registry..."
        ALL_VERSIONS=$(gh api \
          "$API_PREFIX/packages/container/$PACKAGE_NAME/versions" \
          --paginate \
          --jq '.[] | {id: .id, tags: .metadata.container.tags, created: .created_at, updated: .updated_at}' 2>/dev/null || echo "")

        if [ -z "$ALL_VERSIONS" ]; then
          echo "⚠️  No versions found for package: $PACKAGE_NAME"
          echo "This could mean:"
          echo "  - The package doesn't exist"
          echo "  - The token doesn't have read:packages permission"
          echo "  - The package name is incorrect"
          exit 0
        fi

        echo "Available versions in registry:"
        # Use head with proper pipe handling to avoid broken pipe errors
        echo "$ALL_VERSIONS" | head -20 || true
        echo ""

        # Process each version to delete
        for version in $VERSIONS; do
          echo "----------------------------------------"
          echo "Processing Docker image version: $version"
          echo "Expected tag to match: $version"

          # Get the package version ID by matching the tag
          echo "Searching for version with tag '$version'..."

          # Try to get package ID with better error handling
          PACKAGE_INFO=$(gh api \
            "$API_PREFIX/packages/container/$PACKAGE_NAME/versions" \
            --paginate \
            --jq ".[] | select(.metadata.container.tags[]? == \"$version\")" 2>/dev/null || echo "")

          if [ -n "$PACKAGE_INFO" ]; then
            PACKAGE_ID=$(echo "$PACKAGE_INFO" | jq -r '.id' | head -1)
            PACKAGE_TAGS=$(echo "$PACKAGE_INFO" | jq -r '.metadata.container.tags[]' | tr '\n' ', ' | sed 's/,$//')

            echo "✓ Found package version:"
            echo "  - ID: $PACKAGE_ID"
            echo "  - Tags: $PACKAGE_TAGS"
            echo "  - Expected tag: $version"

            if [ -n "$PACKAGE_ID" ] && [[ "$PACKAGE_ID" =~ ^[0-9]+$ ]]; then
              echo "Attempting to delete version ID: $PACKAGE_ID..."

              # Try to delete the package version
              if gh api --method DELETE \
                "$API_PREFIX/packages/container/$PACKAGE_NAME/versions/$PACKAGE_ID" \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" 2>/dev/null; then
                echo "✅ Successfully deleted Docker image version: $version (ID: $PACKAGE_ID)"
              else
                echo "❌ Failed to delete Docker image version: $version (ID: $PACKAGE_ID)"
                echo "   This could mean:"
                echo "   - Token doesn't have delete:packages permission"
                echo "   - Package is protected"
                echo "   - Version doesn't exist anymore"
              fi
            else
              echo "⚠️  Invalid package ID format: $PACKAGE_ID"
            fi
          else
            echo "⚠️  Version '$version' not found in registry"
            echo "   Available tags in registry:"
            # List available tags, handling potential broken pipe errors
            { gh api \
              "$API_PREFIX/packages/container/$PACKAGE_NAME/versions" \
              --paginate \
              --jq '.[].metadata.container.tags[]' 2>/dev/null | sort -u | head -10; } 2>/dev/null || echo "Could not list tags"
          fi
        done

        echo "========================================="
        echo "Docker image cleanup completed"
        echo "========================================="

    - name: Delete Helm Charts from GHCR
      if: steps.versions.outputs.versions != ''
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
      run: |
        # Enhanced deletion with comprehensive debugging

        VERSIONS="${{ steps.versions.outputs.versions }}"
        OWNER="${{ inputs.repo-owner }}"
        CUSTOM_CHART_NAME="${{ inputs.helm-chart-name }}"
        REGISTRY="${{ inputs.registry }}"

        # Convert to lowercase
        OWNER=$(echo "$OWNER" | tr '[:upper:]' '[:lower:]')

        # Use custom name if provided, otherwise use charts/{repo-name}
        if [ -n "$CUSTOM_CHART_NAME" ]; then
          # Check if custom chart name already has URL encoding
          if echo "$CUSTOM_CHART_NAME" | grep -q '%2F'; then
            CHART_NAME="$CUSTOM_CHART_NAME"
            CHART_NAME_DISPLAY=$(echo "$CUSTOM_CHART_NAME" | sed 's/%2F/\//g')
          else
            CHART_NAME_DISPLAY="$CUSTOM_CHART_NAME"
            # URL encode forward slashes if present
            CHART_NAME=$(echo "$CUSTOM_CHART_NAME" | sed 's/\//%2F/g')
          fi
        else
          REPO_NAME="${{ inputs.repo-name }}"
          REPO_NAME=$(echo "$REPO_NAME" | tr '[:upper:]' '[:lower:]')
          # Helm charts typically have the "charts/" prefix
          CHART_NAME_DISPLAY="charts/$REPO_NAME"
          CHART_NAME="charts%2F$REPO_NAME"
        fi

        if [ -z "$VERSIONS" ]; then
          echo "No versions to clean"
          exit 0
        fi

        echo "========================================="
        echo "Helm Chart Deletion Configuration:"
        echo "========================================="
        echo "Registry: $REGISTRY"
        echo "Owner: $OWNER"
        echo "Chart name (display): $CHART_NAME_DISPLAY"
        echo "Chart name (URL encoded): $CHART_NAME"
        echo "Versions to delete: $VERSIONS"
        echo "========================================="

        # First, let's check if we're using organization or user packages
        # Try organization first
        echo "Checking if this is an organization package..."
        ORG_PACKAGES=$(gh api \
          "/orgs/$OWNER/packages?package_type=container" \
          --jq '.[].name' 2>/dev/null || echo "")

        # Check both encoded and decoded versions
        if echo "$ORG_PACKAGES" | grep -q "^$CHART_NAME$\|^$CHART_NAME_DISPLAY$"; then
          PACKAGE_TYPE="org"
          API_PREFIX="/orgs/$OWNER"
          echo "✓ Found as organization package"
        else
          PACKAGE_TYPE="user"
          API_PREFIX="/user"
          echo "✓ Assuming user package (or using GITHUB_TOKEN)"
        fi

        echo "Package type: $PACKAGE_TYPE"
        echo "API prefix: $API_PREFIX"

        # List all available versions first for debugging
        echo ""
        echo "Fetching all available Helm chart versions from registry..."

        # Try with URL-encoded name first
        ALL_VERSIONS=$(gh api \
          "$API_PREFIX/packages/container/$CHART_NAME/versions" \
          --paginate \
          --jq '.[] | {id: .id, tags: .metadata.container.tags, created: .created_at, updated: .updated_at}' 2>/dev/null || echo "")

        # If that fails, try without encoding
        if [ -z "$ALL_VERSIONS" ] && [ "$CHART_NAME" != "$CHART_NAME_DISPLAY" ]; then
          echo "Trying with unencoded chart name: $CHART_NAME_DISPLAY"
          CHART_NAME_UNENCODED=$(echo "$CHART_NAME_DISPLAY" | sed 's/\//%2F/g')
          ALL_VERSIONS=$(gh api \
            "$API_PREFIX/packages/container/$CHART_NAME_UNENCODED/versions" \
            --paginate \
            --jq '.[] | {id: .id, tags: .metadata.container.tags, created: .created_at, updated: .updated_at}' 2>/dev/null || echo "")

          if [ -n "$ALL_VERSIONS" ]; then
            CHART_NAME="$CHART_NAME_UNENCODED"
            echo "✓ Using URL-encoded chart name: $CHART_NAME"
          fi
        fi

        if [ -z "$ALL_VERSIONS" ]; then
          echo "⚠️  No Helm chart versions found for package: $CHART_NAME_DISPLAY"
          echo "This could mean:"
          echo "  - The Helm chart package doesn't exist"
          echo "  - The token doesn't have read:packages permission"
          echo "  - The chart name is incorrect"
          echo "  - Helm charts might not be published to GHCR for this repository"

          # Try to list all container packages to help debug
          echo ""
          echo "Listing all available container packages for debugging:"
          # List packages, handling potential broken pipe errors
          { gh api \
            "$API_PREFIX/packages?package_type=container" \
            --jq '.[].name' 2>/dev/null | head -20; } 2>/dev/null || echo "Could not list packages"

          exit 0
        fi

        echo "Available Helm chart versions in registry:"
        echo "$ALL_VERSIONS" | head -20
        echo ""

        # Process each version to delete
        for version in $VERSIONS; do
          echo "----------------------------------------"
          echo "Processing Helm chart version: $version"
          echo "Expected tag to match: $version"

          # Get the package version ID by matching the tag
          echo "Searching for Helm chart with tag '$version'..."

          # Try to get package ID with better error handling
          PACKAGE_INFO=$(gh api \
            "$API_PREFIX/packages/container/$CHART_NAME/versions" \
            --paginate \
            --jq ".[] | select(.metadata.container.tags[]? == \"$version\")" 2>/dev/null || echo "")

          if [ -n "$PACKAGE_INFO" ]; then
            PACKAGE_ID=$(echo "$PACKAGE_INFO" | jq -r '.id' | head -1)
            PACKAGE_TAGS=$(echo "$PACKAGE_INFO" | jq -r '.metadata.container.tags[]' | tr '\n' ', ' | sed 's/,$//')

            echo "✓ Found Helm chart version:"
            echo "  - ID: $PACKAGE_ID"
            echo "  - Tags: $PACKAGE_TAGS"
            echo "  - Expected tag: $version"

            if [ -n "$PACKAGE_ID" ] && [[ "$PACKAGE_ID" =~ ^[0-9]+$ ]]; then
              echo "Attempting to delete Helm chart version ID: $PACKAGE_ID..."

              # Try to delete the package version
              if gh api --method DELETE \
                "$API_PREFIX/packages/container/$CHART_NAME/versions/$PACKAGE_ID" \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" 2>/dev/null; then
                echo "✅ Successfully deleted Helm chart version: $version (ID: $PACKAGE_ID)"
              else
                echo "❌ Failed to delete Helm chart version: $version (ID: $PACKAGE_ID)"
                echo "   This could mean:"
                echo "   - Token doesn't have delete:packages permission"
                echo "   - Package is protected"
                echo "   - Version doesn't exist anymore"
              fi
            else
              echo "⚠️  Invalid package ID format: $PACKAGE_ID"
            fi
          else
            echo "⚠️  Helm chart version '$version' not found in registry"
            echo "   Available tags in registry:"
            # List available tags, handling potential broken pipe errors
            { gh api \
              "$API_PREFIX/packages/container/$CHART_NAME/versions" \
              --paginate \
              --jq '.[].metadata.container.tags[]' 2>/dev/null | sort -u | head -10; } 2>/dev/null || echo "Could not list tags"
          fi
        done

        echo "========================================="
        echo "Helm chart cleanup completed"
        echo "========================================="

    - name: Delete GitHub Deployment
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
      run: |
        PATTERN="${{ inputs.pattern }}"
        OWNER="${{ inputs.repo-owner }}"
        REPO="${{ inputs.repo-name }}"
        CUSTOM_NAME="${{ inputs.environment-name }}"

        # Determine deployment name
        if [ -n "$CUSTOM_NAME" ]; then
          NAME="$CUSTOM_NAME"
        else
          # Determine deployment name based on pattern
          if [ "$PATTERN" = "rc" ]; then
            NAME="staging"
          elif [[ "$PATTERN" =~ ^pr-[0-9]+$ ]]; then
            NAME="$PATTERN"
          else
            echo "Unknown pattern type: $PATTERN"
            exit 0
          fi
        fi

        echo "Attempting to delete all deployments with environment: $NAME"

        # Get all deployment IDs for this environment
        DEPLOYMENT_IDS=$(gh api \
          -H "Accept: application/vnd.github+json" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          "/repos/$OWNER/$REPO/deployments?environment=$NAME" \
          --jq '.[].id' 2>/dev/null || echo "")

        if [ -n "$DEPLOYMENT_IDS" ]; then
          echo "Found deployment IDs: $DEPLOYMENT_IDS"

          # Loop through each deployment ID
          for DEPLOYMENT_ID in $DEPLOYMENT_IDS; do
            echo "Processing deployment ID: $DEPLOYMENT_ID"

            # First set deployment to inactive
            echo "Setting deployment to inactive..."
            gh api \
              --method POST \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/repos/$OWNER/$REPO/deployments/$DEPLOYMENT_ID/statuses" \
              -f state='inactive' 2>/dev/null || true

            # Delete the deployment
            echo "Deleting deployment..."
            gh api \
              --method DELETE \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/repos/$OWNER/$REPO/deployments/$DEPLOYMENT_ID" \
              && echo "✓ Deleted deployment ID: $DEPLOYMENT_ID" \
              || echo "Failed to delete deployment ID: $DEPLOYMENT_ID"
          done

          echo "✓ Finished processing all deployments for environment: $NAME"
        else
          echo "No deployments found with environment name: $NAME"
        fi

    - name: Delete GitHub Environment
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
      run: |
        PATTERN="${{ inputs.pattern }}"
        OWNER="${{ inputs.repo-owner }}"
        REPO="${{ inputs.repo-name }}"
        CUSTOM_NAME="${{ inputs.environment-name }}"

        # Determine environment name
        if [ -n "$CUSTOM_NAME" ]; then
          NAME="$CUSTOM_NAME"
        else
          # Determine environment name based on pattern
          if [ "$PATTERN" = "rc" ]; then
            NAME="staging"
          elif [[ "$PATTERN" =~ ^pr-[0-9]+$ ]]; then
            NAME="$PATTERN"
          else
            echo "Unknown pattern type: $PATTERN"
            exit 0
          fi
        fi

        echo "Attempting to delete environment: $NAME"

        # Delete the environment
        if gh api \
          --method DELETE \
          -H "Accept: application/vnd.github+json" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          "/repos/$OWNER/$REPO/environments/$NAME" 2>/dev/null; then
          echo "✅ Successfully deleted environment: $NAME"
        else
          echo "⚠️  Failed to delete environment: $NAME (it may not exist or token lacks permissions)"
        fi

branding:
  icon: "trash-2"
  color: "red"
